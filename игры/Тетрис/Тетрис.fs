#if INTERACTIVE
#r "./bin/debug/Xwt.dll"
#r "./bin/debug/FunSharp.dll"
#endif

открыть Библиотека

пусть изменяемый КВАДРАТЫ = 4      // number of boxes per piece
пусть изменяемый ШИРИНАК = 25    // box width in pixels
пусть изменяемый СМЕЩЩЕНИЕX = 40   // Screen X offset in pixels of where the board starts
пусть изменяемый СМЕЩЩЕНИЕY = 40   // Screen Y offset in pixels of where the board starts
пусть изменяемый ШИРИНАХ = 10    // Canvas Width, in number of boxes
пусть изменяемый ВЫСОТАХ = 20   // Canvas Height, in number of boxes.
пусть изменяемый НАЧАЛЬНАЯЗАДЕРЖКА = 800
пусть изменяемый КОНЕЧНАЯЗАДЕРЖКА = 175
пусть изменяемый ПРЕДПРОСМОТР_xпоз = 13
пусть изменяемый ПРЕДПРОСМОТР_yпоз = 2

пусть изменяемый шаблон = ""
пусть изменяемый базовыйшаблон = ""
пусть изменяемый вращение = ""
пусть изменяемый h = ""
пусть изменяемый следующийКусок = ""
пусть изменяемый количествоh = 0
пусть изменяемый xпоз = 0
пусть изменяемый yпоз = 0
пусть изменяемый ``готово`` = 0
пусть изменяемый направлениеДвижения = 0
пусть изменяемый неверноеДвижение = 0
пусть изменяемый задержка = 0
пусть изменяемый счет = 0

тип Шаблон = {
   Значения : int[]
   изменяемый Цвет : Цвет
   изменяемый Разм : int
   изменяемый ViewX : int
   изменяемый ViewY : int
   }

/// Named templates
пусть шаблоны = Словарь<string,Шаблон>()
/// Array of box shape names
тип Квадраты () как this=
   наследует ResizeArray<string>()
   сделать для i = 0 до КВАДРАТЫ-1 сделать this.Add("")
/// Piece name to boxes
пусть куски = System.Collections.Generic.Dictionary<string,Квадраты>()
/// Piece name to template name
пусть кускиКШаблонам = System.Collections.Generic.Dictionary<string,string>()
/// Spots on the grid as shape names
пусть spots = Array.create (ШИРИНАХ*(ВЫСОТАХ+1)) ""

пусть рек ГлавныйЦикл () =
  шаблон <- Текст.Добавить("template", Математика.ВзятьСлучайноеЧисло(7))

  СоздатьКусок() // in: template ret: h
  следующийКусок <- h

  пусть изменяемый ``конец`` = 0
  пусть изменяемый задержкаСессии = НАЧАЛЬНАЯЗАДЕРЖКА
  пока ``конец`` = 0 сделать
    если задержкаСессии > КОНЕЧНАЯЗАДЕРЖКА тогда
      задержкаСессии <- задержкаСессии - 1    

    задержка <- задержкаСессии
    пусть этотКусок = следующийКусок
    шаблон <- Текст.Добавить("template", Математика.ВзятьСлучайноеЧисло(7))

    СоздатьКусок() // in: template ret: h
    следующийКусок <- h
    НарисоватьПредпросмотрКуска()

    h <- этотКусок

    yпоз <- 0
    ``готово`` <- 0
    xпоз <- 3 // always drop from column 3
    ПроверитьОстановку() // in: ypos, xpos, h ret: done
    если ``готово`` = 1 тогда
      yпоз <- yпоз - 1
      ПереместитьКусок()  // in: ypos, xpos, h
      ``конец`` <- 1    

    пусть изменяемый yпоздельта = 0
    пока ``готово`` = 0 || yпоздельта > 0 сделать
      ПереместитьКусок()   // in: ypos, xpos, h

      // Delay, but break if the delay get set to 0 if the piece gets dropped
      пусть изменяемый индексЗадержки = задержка
      пока индексЗадержки > 0 && задержка > 0 сделать
        Программа.Задержка(10)
        индексЗадержки <- индексЗадержки - 10      

      если yпоздельта > 0 тогда
        yпоздельта <- yпоздельта - 1  // used to create freespin, when the piece is rotated
      иначе
        yпоз <- yпоз + 1            // otherwise, move the piece down.      

      // Check if the piece should stop.
      ПроверитьОстановку() // in: ypos, xpos, h ret: done    

и ОбработатьКнопки () =
  // Остановить игру
  если ГрафическоеОкно.ПоследняяКнопка = "Escape" тогда
    Программа.Закончить()  

  // Переместить фигуру влево
  если ГрафическоеОкно.ПоследняяКнопка = "Left" тогда
    направлениеДвижения <- -1
    ВалидироватьДвижение()  // in: ypos, xpos, h, moveDirection ret: invalidMove = 1 or -1 or 2 if move is invalid, otherwise 0
    если неверноеДвижение = 0 тогда
      xпоз <- xпоз + направлениеДвижения   
    ПереместитьКусок()   // in: ypos, xpos, h 

  // Переместить фигуру вправо
  если ГрафическоеОкно.ПоследняяКнопка = "Right" тогда
    направлениеДвижения <- 1
    ВалидироватьДвижение()  // in: ypos, xpos, h, moveDirection ret: invalidMove = 1 or -1 or 2 if move is invalid, otherwise 0
    если неверноеДвижение = 0 тогда
      xпоз <- xпоз + направлениеДвижения    
    ПереместитьКусок()  // in: ypos, xpos, h  

  // Переместить фигуру вниз
  если ГрафическоеОкно.ПоследняяКнопка = "Down" || ГрафическоеОкно.ПоследняяКнопка = "Space" тогда
    задержка <- 0
 
  // Повернуть фигуру
  если ГрафическоеОкно.ПоследняяКнопка = "Up" тогда
    базовыйшаблон <- кускиКШаблонам.[h]
    шаблон <- "temptemplate"
    вращение <- "CW"
    СкопироватьКусок()  // in basetemplate, template, rotation

    кускиКШаблонам.[h] <- шаблон
    направлениеДвижения <- 0
    ВалидироватьДвижение()  // in: ypos, xpos, h, moveDirection ret: invalidMove = 1 or -1 or 2 if move is invalid, otherwise 0

    // See if it can be moved so that it will rotate.
    пусть xпозсхр = xпоз
    пусть изменяемый yпоздельта = 0
    пока yпоздельта = 0 && Математика.Модуль(xпозсхр - xпоз) < 3 сделать // move up to 3 times only
      // if the rotation move worked, copy the temp to "rotatedtemplate" and use that from now on
      если неверноеДвижение = 0 тогда
        базовыйшаблон <- шаблон
        шаблон <- "rotatedtemplate"
        кускиКШаблонам.[h] <- шаблон
        вращение <- "COPY"
        СкопироватьКусок()  // in basetemplate, template, rotation
        yпоздельта <- 1 // Don't move down if we rotate
        ПереместитьКусок()  // in: ypos, xpos, h
      инесли неверноеДвижение = 2 тогда
        // Don't support shifting piece when hitting another piece to the right or left.
        xпоз <- 99 // exit the loop
      иначе
        // if the rotated piece can't be placed, move it left or right and try again.
        xпоз <- xпоз - неверноеДвижение
        ВалидироватьДвижение()  // in: ypos, xpos, h, moveDirection ret: invalidMove = 1 or -1 or 2 if move is invalid, otherwise 0

    если неверноеДвижение <> 0 тогда
      xпоз <- xпозсхр
      кускиКШаблонам.[h] <- базовыйшаблон
      шаблон <- ""

и НарисоватьПредпросмотрКуска () =
  xпоз <- ПРЕДПРОСМОТР_xпоз
  yпоз <- ПРЕДПРОСМОТР_yпоз
  h <- следующийКусок

  пусть СМЕЩЩЕНИЕXСОХР = СМЕЩЩЕНИЕX
  пусть СМЕЩЩЕНИЕYСОХР = СМЕЩЩЕНИЕY
  СМЕЩЩЕНИЕX <- СМЕЩЩЕНИЕX - 20 + шаблоны.[кускиКШаблонам.[h]].ViewX
  СМЕЩЩЕНИЕY <- СМЕЩЩЕНИЕY + шаблоны.[кускиКШаблонам.[h]].ViewY
  ПереместитьКусок()  // in: ypos, xpos, h

  СМЕЩЩЕНИЕX <- СМЕЩЩЕНИЕXСОХР
  СМЕЩЩЕНИЕY <- СМЕЩЩЕНИЕYСОХР

// creates template that's a rotated basetemplate
и СкопироватьКусок () = // in basetemplate, template, rotation 
  пусть L = шаблоны.[базовыйшаблон].Разм

  если not (шаблоны.ContainsKey шаблон) тогда
      шаблоны.[шаблон] <-
         { Значения=[|0;0;0;0|]; Цвет=Цвета.Black; Разм=0; ViewX=0; ViewY=0 }        

  если вращение = "CW" тогда
    для i = 0 до КВАДРАТЫ - 1 сделать // x' = y y' = L - 1 - x
      пусть v = шаблоны.[базовыйшаблон].Значения.[i]

      //x = Math.Floor(v/10)
      //y = Math.Remainder(v, 10)

      // new x and y
      пусть x = (Математика.Остаток(v, 10))
      пусть y = (L - 1 - Математика.Floor(float v/10.0))
      шаблоны.[шаблон].Значения.[i] <- x * 10 + y
    
  // Против часовой стрелки сейчас не используется
  инесли вращение = "CCW" тогда
    для i = 0 до КВАДРАТЫ - 1 сделать // x' = L - 1 - y y' = x
      пусть v = шаблоны.[базовыйшаблон].Значения.[i]
      //x = Math.Floor(v/10)
      //y = Math.Remainder(v, 10)

      // new x and y
      пусть x = (L - 1 - Математика.Остаток(v, 10))
      пусть y = Математика.Floor(float v / 10.0)
      шаблоны.[шаблон].Значения.[i] <- x * 10 + y
    
  инесли вращение = "COPY" тогда
    для i = 0 до КВАДРАТЫ - 1 сделать
      шаблоны.[шаблон].Значения.[i] <- шаблоны.[базовыйшаблон].Значения.[i]
  иначе
    ГрафическоеОкно.ПоказатьСообщение("invalid parameter", "Error")
    Программа.Закончить() 

  // Copy the remain properties from basetemplate to template.
  шаблоны.[шаблон].Цвет <- шаблоны.[базовыйшаблон].Цвет
  шаблоны.[шаблон].Разм <- шаблоны.[базовыйшаблон].Разм
  шаблоны.[шаблон].ViewX <- шаблоны.[базовыйшаблон].ViewX
  шаблоны.[шаблон].ViewY <- шаблоны.[базовыйшаблон].ViewY

и СоздатьКусок () = // in: template ret: h
  // Create a new handle, representing an arrayName, that will represent the piece
  количествоh <- количествоh + 1
  h <- Текст.Добавить("piece", количествоh)

  кускиКШаблонам.[h] <- шаблон

  ГрафическоеОкно.ШиринаПера <- 1.0
  ГрафическоеОкно.ЦветПера <- Цвета.Black
  ГрафическоеОкно.ЦветКисти <- шаблоны.[шаблон].Цвет

  куски.[h] <- Квадраты()
  для i = 0 до КВАДРАТЫ - 1 сделать
    пусть s = Фигуры.ДобавитьПрямоугольник(ШИРИНАК, ШИРИНАК)
    Фигуры.Переместить(s, -ШИРИНАК, -ШИРИНАК) // move off screen
    куски.[h].[i] <- s    

и ПереместитьКусок () = // in: ypos, xpos, h. ypos/xpos is 0-19, representing the top/left box coordinate of the piece on the canvas. h returned by CreatePiece
  для i = 0 до КВАДРАТЫ - 1 сделать
    пусть v = шаблоны.[кускиКШаблонам.[h]].Значения.[i]
    пусть x = Математика.Floor(float v / 10.0)
    пусть y = Математика.Остаток(v, 10)

    // Array.GetValue(h, i) = box for piece h.
    // xpos/ypos = are topleft of shape. x/y is the box offset within the shape.
    Фигуры.Переместить(куски.[h].[i], СМЕЩЩЕНИЕX + xпоз * ШИРИНАК + x * ШИРИНАК, СМЕЩЩЕНИЕY + yпоз * ШИРИНАК + y * ШИРИНАК)  

и ВалидироватьДвижение () = // in: ypos, xpos, h, moveDirection ret: invalidMove = 1 or -1 or 2 if move is invalid, otherwise 0
  пусть изменяемый i = 0
  неверноеДвижение <- 0
  пока i < КВАДРАТЫ сделать
    пусть v = шаблоны.[кускиКШаблонам.[h]].Значения.[i]

    // x/y is the box offset within the shape.
    пусть x = Математика.Floor(float v / 10.0)
    пусть y = Математика.Остаток(v, 10)

    если (x + xпоз + направлениеДвижения) < 0 тогда
      неверноеДвижение <- -1
      i <- КВАДРАТЫ // force getting out of the loop    

    если (x + xпоз + направлениеДвижения) >= ШИРИНАХ тогда
      неверноеДвижение <- 1
      i <- КВАДРАТЫ // force getting out of the loop   

    если spots.[(x + xпоз + направлениеДвижения) + (y + yпоз) * ШИРИНАХ] <> "." тогда
      неверноеДвижение <- 2
      i <- КВАДРАТЫ // force getting out of the loop    

    i <- i + 1 

и ПроверитьОстановку () = // in: ypos, xpos, h ret: done
  ``готово`` <- 0
  пусть изменяемый i = 0
  пока i < КВАДРАТЫ сделать
    пусть v = шаблоны.[кускиКШаблонам.[h]].Значения.[i]

    // x/y is the box offset within the shape.
    пусть x = Математика.Floor(float v / 10.0)
    пусть y = Математика.Остаток(v, 10)

    если y + yпоз > ВЫСОТАХ || spots.[(x + xпоз) + (y + yпоз) * ШИРИНАХ] <> "." тогда
      ``готово`` <- 1
      i <- КВАДРАТЫ // force getting out of the loop   

    i <- i + 1 

  // If we need to stop the piece, move the box handles до the canvas
  если ``готово`` = 1 тогда
    для i = 0 до КВАДРАТЫ - 1 сделать
      пусть v = шаблоны.[кускиКШаблонам.[h]].Значения.[i]
      //x = Math.Floor(v/10)
      //y = Math.Remainder(v, 10)
      пусть x = (Математика.Floor(float v / 10.0) + xпоз)
      пусть y = (Математика.Остаток(v, 10) + yпоз - 1)
      если y >= 0 тогда
         spots.[x + y * ШИРИНАХ] <- куски.[h].[i]

    // 1 points for every piece successfully dropped
    счет <- счет + 1
    НапечататьСчет()

    // Delete cleared lines
    DeleteLines()

и DeleteLines () =
  пусть изменяемый linesCleared = 0

  // Iterate over each row, starting from the bottom
  для y = ВЫСОТАХ - 1 downto 0 сделать

    // Check to see if the whole row is filled
    пусть изменяемый x = ШИРИНАХ
    пока x = ШИРИНАХ сделать
      x <- 0
      пока x < ШИРИНАХ сделать
        пусть piece = spots.[x + y * ШИРИНАХ]
        если piece = "." тогда
          x <- ШИРИНАХ        
        x <- x + 1    

      // if non of them were empty (i.e "."), then remove the line.
      если x = ШИРИНАХ тогда

        // Delete the line
        для x1 = 0 до ШИРИНАХ - 1 сделать
          Фигуры.Удалить(spots.[x1 + y * ШИРИНАХ])
        linesCleared <- linesCleared + 1

        // Move everything else down one.
        для y1 = y downto 1 сделать
          для x1 = 0 до ШИРИНАХ - 1 сделать
            пусть piece = spots.[x1 + (y1 - 1) * ШИРИНАХ]
            spots.[x1 + y1 * ШИРИНАХ] <- piece
            Фигуры.Переместить(piece, Фигуры.ПолучитьЛево(piece), Фигуры.ПолучитьВерх(piece) + float ШИРИНАК)

  если linesCleared > 0 тогда
    счет <- счет + 100 * int (Математика.Округлить(float linesCleared * 2.15 - 1.0))
    НапечататьСчет()

и НастроитьХолст () =
// GraphicsWindow.DrawResizedImage( Flickr.GetRandomPicture( "bricks" ), 0, 0, GraphicsWindow.Width, GraphicsWindow.Height)

  ГрафическоеОкно.ЦветКисти <- ГрафическоеОкно.ЦветФона
  ГрафическоеОкно.ЗаполнитьПрямоугольник(СМЕЩЩЕНИЕX, СМЕЩЩЕНИЕY, ШИРИНАХ*ШИРИНАК, ВЫСОТАХ*ШИРИНАК)

  Программа.Задержка(200)
  ГрафическоеОкно.ШиринаПера <- 1.0
  ГрафическоеОкно.ЦветПера <- Цвета.Pink
  для x = 0 до ШИРИНАХ-1 сделать
    для y = 0 до ВЫСОТАХ-1 сделать
      spots.[x + y * ШИРИНАХ] <- "." // "." indicates spot is free
      ГрафическоеОкно.НарисоватьПрямоугольник(СМЕЩЩЕНИЕX + x * ШИРИНАК, СМЕЩЩЕНИЕY + y * ШИРИНАК, ШИРИНАК, ШИРИНАК)

  ГрафическоеОкно.ШиринаПера <- 4.0
  ГрафическоеОкно.ЦветПера <- Цвета.Black
  ГрафическоеОкно.НарисоватьЛинию(СМЕЩЩЕНИЕX, СМЕЩЩЕНИЕY, СМЕЩЩЕНИЕX, СМЕЩЩЕНИЕY + ВЫСОТАХ*ШИРИНАК)
  ГрафическоеОкно.НарисоватьЛинию(СМЕЩЩЕНИЕX + ШИРИНАХ*ШИРИНАК, СМЕЩЩЕНИЕY, СМЕЩЩЕНИЕX + ШИРИНАХ*ШИРИНАК, СМЕЩЩЕНИЕY + ВЫСОТАХ*ШИРИНАК)
  ГрафическоеОкно.НарисоватьЛинию(СМЕЩЩЕНИЕX, СМЕЩЩЕНИЕY + ВЫСОТАХ*ШИРИНАК, СМЕЩЩЕНИЕX + ШИРИНАХ*ШИРИНАК, СМЕЩЩЕНИЕY + ВЫСОТАХ*ШИРИНАК)

  ГрафическоеОкно.ЦветПера <- Цвета.Lime
  ГрафическоеОкно.НарисоватьЛинию(СМЕЩЩЕНИЕX - 4, СМЕЩЩЕНИЕY, СМЕЩЩЕНИЕX - 4, СМЕЩЩЕНИЕY + ВЫСОТАХ*ШИРИНАК + 6)
  ГрафическоеОкно.НарисоватьЛинию(СМЕЩЩЕНИЕX + ШИРИНАХ*ШИРИНАК + 4, СМЕЩЩЕНИЕY, СМЕЩЩЕНИЕX + ШИРИНАХ*ШИРИНАК + 4, СМЕЩЩЕНИЕY + ВЫСОТАХ*ШИРИНАК + 6)
  ГрафическоеОкно.НарисоватьЛинию(СМЕЩЩЕНИЕX - 4, СМЕЩЩЕНИЕY + ВЫСОТАХ*ШИРИНАК + 4, СМЕЩЩЕНИЕX + ШИРИНАХ*ШИРИНАК + 4, СМЕЩЩЕНИЕY + ВЫСОТАХ*ШИРИНАК + 4)

  ГрафическоеОкно.ЦветПера <- Цвета.Black
  ГрафическоеОкно.ЦветКисти <- Цвета.Pink
  пусть x = СМЕЩЩЕНИЕX + ПРЕДПРОСМОТР_xпоз * ШИРИНАК - ШИРИНАК
  пусть y = СМЕЩЩЕНИЕY + ПРЕДПРОСМОТР_yпоз * ШИРИНАК - ШИРИНАК
  ГрафическоеОкно.ЗаполнитьПрямоугольник(x - 20, y, ШИРИНАК * 5, ШИРИНАК * 6)
  ГрафическоеОкно.НарисоватьПрямоугольник(x - 20, y, ШИРИНАК * 5, ШИРИНАК * 6)

  ГрафическоеОкно.ЗаполнитьПрямоугольник(x - 20, y + 190, 310, 170)
  ГрафическоеОкно.НарисоватьПрямоугольник(x - 20, y + 190, 310, 170)

  ГрафическоеОкно.ЦветКисти <- Цвета.Black
  ГрафическоеОкно.КурсивностьШрифта <- ложь
  ГрафическоеОкно.ИмяШрифта <- "Comic Sans MS"
  ГрафическоеОкно.РазмерШрифта <- 16.0
  ГрафическоеОкно.НарисоватьТекст(x, y + 200, "Game control keys:")
  ГрафическоеОкно.НарисоватьТекст(x + 25, y + 220, "Left Arrow = Move piece left")
  ГрафическоеОкно.НарисоватьТекст(x + 25, y + 240, "Right Arrow = Move piece right")
  ГрафическоеОкно.НарисоватьТекст(x + 25, y + 260, "Up Arrow = Rotate piece")
  ГрафическоеОкно.НарисоватьТекст(x + 25, y + 280, "Down Arrow = Drop piece")
  ГрафическоеОкно.НарисоватьТекст(x, y + 320, "Press до stop game")

  Программа.Задержка(200) // without this delay, the above text will use the fontsize of the score 

  ГрафическоеОкно.ЦветКисти <- Цвета.Black
  ГрафическоеОкно.ИмяШрифта <- "Georgia"
  ГрафическоеОкно.КурсивностьШрифта <- истина
  ГрафическоеОкно.РазмерШрифта <- 36.0
  ГрафическоеОкно.НарисоватьТекст(x - 20, y + 400, "Small Basic Tetris")
  Программа.Задержка(200) // without this delay, the above text will use the fontsize of the score 
  ГрафическоеОкно.РазмерШрифта <- 16.0
  ГрафическоеОкно.НарисоватьТекст(x - 20, y + 440, "ver.0.1")

  Программа.Задержка(200) // without this delay, the above text will use the fontsize of the score 
  счет <- 0
  НапечататьСчет()

и НапечататьСчет () =
  ГрафическоеОкно.ШиринаПера <- 4.0
  ГрафическоеОкно.ЦветКисти <- Цвета.Pink
  ГрафическоеОкно.ЗаполнитьПрямоугольник(480, 65, 150, 50)
  ГрафическоеОкно.ЦветКисти <- Цвета.Black
  ГрафическоеОкно.НарисоватьПрямоугольник(480, 65, 150, 50)
  ГрафическоеОкно.КурсивностьШрифта <- ложь
  ГрафическоеОкно.РазмерШрифта <- 32.0
  ГрафическоеОкно.ИмяШрифта <- "Impact"
  ГрафическоеОкно.ЦветКисти <- Цвета.Black
  ГрафическоеОкно.НарисоватьТекст(485, 70, Текст.Добавить(Текст.ПолучитьПодТекст( "00000000", 0, 8 - Текст.ПолучитьДлину( string счет ) ), счет))

и НастроитьШаблоны () =
  // each piece has 4 boxes.
  // the index of each entry within a piece represents the box number (1-4)
  // the value of each entry represents to box zero-based box coordinate within the piece: tens place is x, ones place y

  //_X_
  //_X_
  //_XX
  шаблоны.["template1"] <- { Значения=[|10;11;12;22|]; Цвет=Цвета.Yellow; Разм=3; ViewX = -12; ViewY = 12 }

  //_X_
  //_X_
  //XX_
  шаблоны.["template2"] <- { Значения=[|10;11;12;02|]; Цвет=Цвета.Magenta; Разм=3; ViewX=12; ViewY=12 }

  //_X_
  //XXX
  //_
  шаблоны.["template3"] <- { Значения=[|10;01;11;21|]; Цвет=Цвета.Gray; Разм=3; ViewX=0; ViewY=25}

  //XX_
  //XX_
  //_
  шаблоны.["template4"] <- { Значения=[|00;10;01;11|]; Цвет=Цвета.Cyan; Разм=2; ViewX=12; ViewY=25 }

  //XX_
  //_XX
  //_
  шаблоны.["template5"] <- { Значения=[|00;10;11;21|]; Цвет=Цвета.Green; Разм=3; ViewX=0; ViewY=25 }

  //_XX
  //XX_
  //_
  шаблоны.["template6"] <- { Значения=[|10;20;01;11|]; Цвет=Цвета.Blue; Разм=3; ViewX=0; ViewY=25}

  //_X
  //_X
  //_X
  //_X
  шаблоны.["template7"] <- { Значения=[|10;11;12;13|]; Цвет=Цвета.Red; Разм=4; ViewX=0; ViewY=0}

ГрафическоеОкно.Высота <- 580
ГрафическоеОкно.Ширина <- 700
ГрафическоеОкно.КнопкаНажата <- Callback(ОбработатьКнопки)
ГрафическоеОкно.ЦветФона <- ГрафическоеОкно.ПолучитьЦветИзRGB( 253, 252, 251 )

пока истина сделать
  КВАДРАТЫ <- 4      // number of boxes per piece
  ШИРИНАК <- 25    // box width in pixels
  СМЕЩЩЕНИЕX <- 40   // Screen X offset in pixels of where the board starts
  СМЕЩЩЕНИЕY <- 40   // Screen Y offset in pixels of where the board starts
  ШИРИНАХ <- 10    // Ширина Холста в количестве квадратов
  ВЫСОТАХ <- 20   // Высота Холста в количестве квадратов.
  НАЧАЛЬНАЯЗАДЕРЖКА <- 800
  КОНЕЧНАЯЗАДЕРЖКА <- 175
  ПРЕДПРОСМОТР_xпоз <- 13
  ПРЕДПРОСМОТР_yпоз <- 2

  ГрафическоеОкно.Очистить()
  ГрафическоеОкно.Заголовок <- "Small Basic Tetris"

  ГрафическоеОкно.Показать()

  НастроитьШаблоны()
  НастроитьХолст()
  ГлавныйЦикл()

  ГрафическоеОкно.ПоказатьСообщение( "Игра завершена", "Small Basic Tetris" )


